<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>SlimPipeline</name></assembly>
<members>
<member name="T:SlimPipeline.Stage`2">
<summary>
 Stage describes *what* should be done:
 - Contains high-level metadata
 - Encodes memory transition intent
 - Suitable for planning, validation, and analysis
 - Stage + ProfileTransition: what happens
</summary>
</member>
<member name="T:SlimPipeline.ProfileTransition">
<summary>
 ProfileTransition describes *how* memory layout is expected to change:
 - From: the input memory profile
 - To: the expected output memory profile
</summary>
</member>
<member name="T:SlimPipeline.Pipe`2">
<summary>
 A configurable image processing step that operates on image slices.
 Pipe describes *how* to do it:
 - Encapsulates the concrete execution logic
 - Defines memory usage behavior
 - Takes and returns AsyncSeq streams
 - Pipe + WindowedProcessor: How it’s computed 
</summary>
</member>
<member name="T:SlimPipeline.Profile">
<summary>
 The memory usage strategies during image processing.
</summary>
</member>
<member name="M:SlimPipeline.Pipeline.sink(SlimPipeline.Pipeline{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 sink type operators
</summary>
</member>
<member name="M:SlimPipeline.Pipeline.op_GreaterEqualsGreaterGreater``4(SlimPipeline.Pipeline{``0,``1},SlimPipeline.Stage{``1,``2},SlimPipeline.Stage{``1,``3})">
<summary>
 parallel fanout with synchronization
</summary>
</member>
<member name="M:SlimPipeline.Pipeline.compose``3(SlimPipeline.Pipeline{``0,``1},SlimPipeline.Stage{``1,``2})">
<summary>
 Composition operators
</summary>
</member>
<member name="M:SlimPipeline.Pipeline.source(Microsoft.FSharp.Core.FSharpFunc{System.UInt64,System.UInt64},System.UInt64)">
<summary>
 Source type operators
</summary>
</member>
<member name="M:SlimPipeline.Pipe.mapWindowed``2(System.String,System.UInt32,Microsoft.FSharp.Core.FSharpFunc{System.UInt32,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.UInt32,Microsoft.FSharp.Core.FSharpFunc{``0,``0},System.UInt32,System.UInt32,System.UInt32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
 mapWindowed keeps a running window along the slice direction of depth images
 and processes them by f. The stepping size of the running window is stride.
 So if depth is 3 and stride is 1 then first image 0,1,2 is sent to f, then 1, 2, 3
 and so on. If depth is 3 and stride is 3, then it&apos;ll be image 0, 1, 2 followed by
 3, 4, 5. It is also possible to use this for sampling, e.g., setting depth to 1
 and stride to 2 sends every second image to f.  
</summary>
</member>
<member name="M:SlimPipeline.Pipe.shrinkProfile``2(System.UInt64,System.UInt64,System.UInt32,SlimPipeline.Pipe{``0,``1})">
<summary>
 Try to shrink a too‑hungry pipe to a cheaper profile.
 *You* control the downgrade policy here.
</summary>
</member>
<member name="M:SlimPipeline.Pipe.compose``3(SlimPipeline.Pipe{``0,``1},SlimPipeline.Pipe{``1,``2})">
<summary>
 Combine two &lt;c&gt;Pipe&lt;/c&gt; instances into one by composing their memory profiles and transformation functions.
</summary>
</member>
</members>
</doc>
